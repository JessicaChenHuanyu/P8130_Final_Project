---
title: "Code"
output: pdf_document
---

```{r, include=FALSE}
library(dplyr)
library(ggplot2)
library(tidyr)
library(knitr)
library(MASS)
library(glmnet)

set.seed(1)
```

# Read and Clean Data
```{r}
data <- read.csv("./data.csv") |>
  janitor::clean_names() |>
  mutate(
    gender = case_when(
      gender == "male" ~ 0,
      gender == "female" ~ 1,
      ),
    ethnic_group = case_when(
      ethnic_group == "group A" ~ 0,
      ethnic_group == "group B" ~ 1,
      ethnic_group == "group C" ~ 2,
      ethnic_group == "group D" ~ 3,
      ethnic_group == "group E" ~ 4,
      ),
    parent_educ = case_when(
      parent_educ == "some highschool" ~ 0,
      parent_educ == "some college" ~ 1,
      parent_educ == "associate's degree" ~ 2,
      parent_educ == "bachelor's degree" ~ 3,
      parent_educ == "master's degree" ~ 4,
      ),
    lunch_type = case_when(
      lunch_type == "standard" ~ 0,
      lunch_type == "free/reduced" ~ 1,
      ),
    test_prep = case_when(
      test_prep == "none" ~ 0,
      test_prep == "completed" ~ 1,
      ),
    parent_marital_status = case_when(
      parent_marital_status == "married" ~ 0,
      parent_marital_status == "single" ~ 1,
      parent_marital_status == "widowed" ~ 2,
      parent_marital_status == "divorced" ~ 3,
      ),
    practice_sport = case_when(
      practice_sport == "never" ~ 0,
      practice_sport == "sometimes" ~ 1,
      practice_sport == "regularly" ~ 2,
      ),
    is_first_child = case_when(
      is_first_child == "no" ~ 0,
      is_first_child == "yes" ~ 1,
      ),
    transport_means = case_when(
      transport_means == "school_bus" ~ 0,
      transport_means == "private" ~ 1,
      ),
    wkly_study_hours = case_when(
      wkly_study_hours == "< 5" ~ 0,
      wkly_study_hours == "10-May" ~ 1,
      wkly_study_hours == "> 10" ~ 2,
      )
    )


# Deal with NA -- Calculate the column mean (round to integer) and plug it into NA cell
column_means <- round(colMeans(data, na.rm = TRUE), digits = 0)
for (col in names(data)) {
  data[[col]][is.na(data[[col]])] <- column_means[col]
  }

head(data)

# Another data set for EDA
data_long <- data |>
  pivot_longer(cols = c(math_score, reading_score, writing_score),
               names_to = "test", values_to = "score")
```

# Summary
```{r}
transposed_summary <- t(summary(data))
knitr::kable(transposed_summary, caption = "Summary Statistics for Data", 2)
```

# Histograms
```{r}
ggplot(data, aes(x = math_score)) +
  geom_histogram(binwidth = 5, fill = "skyblue", color = "black") +
  labs(title = "Math Score Distribution")
ggplot(data, aes(x = reading_score)) +
  geom_histogram(binwidth = 5, fill = "salmon", color = "black") +
  labs(title = "Reading Score Distribution")
ggplot(data, aes(x = writing_score)) +
  geom_histogram(binwidth = 5, fill = "lightgreen", color = "black") +
  labs(title = "Writing Score Distribution")
```

# Boxplots
```{r}
ggplot(data_long, aes(x = test, y = score, fill = test)) +
  geom_boxplot() +
  labs(title = "Scores Boxplot", x = "Test Type", y = "Score") +
  facet_wrap(~ test, scales = "free") +
  scale_fill_manual(values = c("skyblue", "salmon", "lightgreen"))
```

# Diagnostics
```{r}
# Math
model_math_full = lm(math_score ~ .-reading_score -writing_score, data = data)

par(mfrow = c(2,2))
plot(model_math_full)

# reading
model_reading_full = lm(reading_score ~ .-math_score -writing_score, data = data)

par(mfrow = c(2,2))
plot(model_reading_full)

# writing
model_writing_full = lm(writing_score ~ .-reading_score -math_score, data = data)

par(mfrow = c(2,2))
plot(model_writing_full)

```

# Transformation
```{r}
boxcox(model_reading_full)
```

# Outlier and influence points
```{r}
plot(model_math_full, which = 4)
plot(model_reading_full, which = 4)
plot(model_writing_full, which = 4)
```

# Multicollinearity
```{r}
# check VIF
performance::check_collinearity(model_math_full)
performance::check_collinearity(model_reading_full)
performance::check_collinearity(model_writing_full)
```

# Model building for math
```{r}
# backward model
step(model_math_full, direction='backward')

model_math_fit_back = lm(formula = math_score ~ gender + ethnic_group + parent_educ + 
    lunch_type + test_prep + parent_marital_status + practice_sport + 
    is_first_child + wkly_study_hours, data = data)

summary(model_math_fit_back)


# lasso model
lambda_seq = 10 ^ seq(-3, 0, by = .1)

cv_object_math = cv.glmnet(as.matrix(data[1:11]), data$math_score,
                         lambda = lambda_seq,
                         nfolds = 5)

model_math_lasso = glmnet(as.matrix(data[1:11]), data$math_score, lambda = cv_object_math$lambda.min, alpha = 1)
coef(model_math_lasso)
model_math_lasso$dev.ratio
```

# Model building for reading
```{r}
# backward model
step(model_reading_full, direction='backward')
model_reading_back = lm(formula = reading_score ~ gender + ethnic_group + parent_educ + 
    lunch_type + test_prep + parent_marital_status + is_first_child + 
    transport_means + wkly_study_hours, data = data)
summary(model_reading_back)


# lasso model
lambda_seq = 10 ^ seq(-3, 0, by = .1)

cv_object_reading = cv.glmnet(as.matrix(data[1:11]), data$reading_score,
                         lambda = lambda_seq,
                         nfolds = 5)
cv_object_reading$lambda.min

model_reading_lasso = glmnet(as.matrix(data[1:11]), data$reading_score, lambda = cv_object_reading$lambda.min)
coef(model_reading_lasso)
model_reading_lasso$dev.ratio
```

# Model building for writing
```{r}
# backward model
step(model_writing_full, direction = "backward", )
model_writing_back = lm(formula = writing_score ~ gender + ethnic_group + parent_educ + 
    lunch_type + test_prep + parent_marital_status + practice_sport + 
    is_first_child + transport_means + wkly_study_hours, data = data)
summary(model_writing_back)


# lasso model
lambda_seq = 10 ^ seq(-3, 0, by = .1)

cv_object_writing = cv.glmnet(as.matrix(data[1:11]), data$writing_score,
                         lambda = lambda_seq,
                         nfolds = 5)
cv_object_writing$lambda.min

model_writing_lasso = glmnet(as.matrix(data[1:11]), data$writing_score, lambda = cv_object_writing$lambda.min)
coef(model_writing_lasso)
model_writing_lasso$dev.ratio

```



